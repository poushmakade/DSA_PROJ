<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trees in DSA: Terminologies, Binary Trees, and Binary Search Trees (BST)</title>
    <link rel="stylesheet" href="sty1.css"> <!-- Linking external CSS -->
    <script src="scr1.js" defer></script> <!-- Linking external JavaScript -->
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 20px;
            transition: background-color 0.5s, color 0.5s;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
        }

        .content {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #27ae60;
            cursor: pointer;
        }

        p {
            line-height: 1.6;
        }

        .tree-diagram {
            text-align: center;
            margin: 20px 0;
        }

        .footer {
            text-align: right;
            margin-top: 30px;
            color: #888;
            font-size: 12px;
        }

        .subsection {
            margin-top: 40px;
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }

        .video-section {
            background-color: #eafaf1;
            border: 2px solid #27ae60;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .video-section a {
            color: #27ae60;
            font-weight: bold;
            text-decoration: underline;
        }

        .credits {
            margin-top: 40px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .code {
            background-color: #f8f8f8;
            border-left: 3px solid #27ae60;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
        }

        pre {
            margin: 0;
            padding: 0;
        }

        /* Button styling */
        .btn {
            display: inline-block;
            margin: 10px 0;
            padding: 10px 20px;
            background-color: #27ae60;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #219150;
        }

        /* Tree diagram styling */
        .tree-representation {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            flex-direction: column;
        }

        .node {
            border: 1px solid #27ae60;
            border-radius: 5px;
            padding: 10px 15px;
            margin: 5px;
            background-color: #eafaf1;
            position: relative;
            text-align: center;
            width: 60px;
        }

        .children {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }

        .horizontal-line {
            position: absolute;
            top: 25px;
            left: 50%;
            width: 50%;
            height: 1px;
            background-color: #27ae60;
            z-index: -1;
        }

        .node.left::after {
            content: '';
            position: absolute;
            width: 50%;
            height: 20px;
            top: 0;
            left: 0;
            border-left: 1px solid #27ae60;
            border-bottom: 1px solid #27ae60;
            border-radius: 0 0 0 5px;
        }

        .node.right::after {
            content: '';
            position: absolute;
            width: 50%;
            height: 20px;
            top: 0;
            right: 0;
            border-right: 1px solid #27ae60;
            border-bottom: 1px solid #27ae60;
            border-radius: 0 0 5px 0;
        }

        .children > .node {
            position: relative;
        }
    </style>
</head>
<body>
    <a class="btn" href="index.html">Home</a>
    <a class="btn" href="contact.html">Contact</a>
    <h1>Trees in DSA: Terminologies, Binary Trees, and Binary Search Trees (BST)</h1>

    <div class="content">
        <!-- Section 1: Basic Tree Terminologies -->
        <h2 onclick="toggleVisibility('terminologies')">Basic Tree Terminologies</h2>
        <div id="terminologies">
            <p>A tree is a hierarchical data structure that consists of nodes connected by edges. It is widely used in various applications such as representing hierarchical relationships, organizing data for quick search and retrieval, and more.</p>
            <ul>
                <li><strong>Node:</strong> A fundamental part of a tree that contains a value or data.</li>
                <li><strong>Root:</strong> The topmost node in a tree. Every tree has a single root node.</li>
                <li><strong>Edge:</strong> A connection between two nodes. It represents the parent-child relationship.</li>
                <li><strong>Parent:</strong> A node that has one or more child nodes.</li>
                <li><strong>Child:</strong> A node that descends from another node (its parent).</li>
                <li><strong>Subtree:</strong> A portion of the tree that consists of a node and all its descendants.</li>
                <li><strong>Height of a Tree:</strong> The longest path from the root to a leaf node.</li>
            </ul>
        </div>

        <!-- Section 2: Binary Tree and Operations -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('binaryTree')">Binary Trees and Operations</h2>
            <div id="binaryTree">
                <p>A binary tree is a type of tree in which each node has at most two children, referred to as the left child and the right child. A binary tree is widely used due to its efficient searching capabilities.</p>

                <h3>Basic Operations of Binary Tree</h3>
                <ul>
                    <li><strong>Inserting a Node:</strong> Inserting data into the binary tree while maintaining its properties.</li>
                    <li><strong>Deleting a Node:</strong> Removing a node while ensuring the tree remains a valid binary tree.</li>
                    <li><strong>Traversal:</strong> Visiting each node in the tree using methods like Pre-order, In-order, and Post-order traversal.</li>
                    <li><strong>Searching:</strong> Finding a node in the binary tree.</li>
                    <li><strong>Height Calculation:</strong> Finding the height of the binary tree, which is the longest path from the root node to a leaf node.</li>
                </ul>

                <h3>Example: Creating and Adding Nodes to a Binary Tree in C</h3>
                <div class="code">
                    <pre>
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int value;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->value) {
        root->left = insert(root->left, value);
    } else if (value > root->value) {
        root->right = insert(root->right, value);
    }
    return root;
}

// Example usage
int main() {
    struct Node* root = NULL;
    root = insert(root, 10);  // Add root node
    insert(root, 5);           // Add left child
    insert(root, 15);          // Add right child
    printf("Binary Tree Created with nodes 10, 5, and 15.\n");
    return 0;
}
                    </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="s.html">Go to Binary Search Tree Implementation</a>
            </div>
        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Binary Search Trees -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('bst')">Binary Search Trees (BST)</h2>
            <div id="bst">
                <p>A Binary Search Tree is a binary tree with the following properties:</p>
                <ul>
                    <li>The left subtree of a node contains only nodes with values less than the node’s value.</li>
                    <li>The right subtree of a node contains only nodes with values greater than the node’s value.</li>
                    <li>Both the left and right subtrees are also binary search trees.</li>
                </ul>

                <h3>Operations on BST</h3>
                <ul>
                    <li><strong>Insertion:</strong> O(log n) in average and O(n) in the worst case.</li>
                    <li><strong>Search:</strong> O(log n) in average and O(n) in the worst case.</li>
                    <li><strong>Delete:</strong> O(log n) in average and O(n) in the worst case (unbalanced tree).</li>
                </ul>

                <h3>C Example: Creating a Binary Search Tree</h3>
                <div class="code">
                    <pre>
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int value;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

struct Node* insertBST(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->value) {
        root->left = insertBST(root->left, value);
    } else {
        root->right = insertBST(root->right, value);
    }
    return root;
}

// Example usage
int main() {
    struct Node* root = NULL;
    root = insertBST(root, 10);  // Add root node
    insertBST(root, 5);           // Add left child
    insertBST(root, 15);          // Add right child
    printf("Binary Search Tree Created with nodes 10, 5, and 15.\n");
    return 0;
}
            </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="2.html">Go to Threaded Binary Tree Implementation</a>
            </div>
        </div>

        <!-- Section 4: Threaded Binary Trees -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('threadedTree')">Threaded Binary Trees</h2>
            <div id="threadedTree">
                <p>A threaded binary tree is a type of binary tree where the null pointers of the nodes are made to point to the in-order predecessor and successor. This allows for efficient in-order traversal without using a stack or recursion.</p>

                <h3>Advantages of Threaded Binary Trees</h3>
                <ul>
                    <li>Improved traversal efficiency.</li>
                    <li>Reduces the overhead of using a stack for traversal.</li>
                    <li>Memory-efficient as it utilizes the null pointers.</li>
                </ul>

                <h3>C Example: Creating a Threaded Binary Tree</h3>
                <div class="code">
                    <pre>
struct ThreadedNode {
    int value;
    struct ThreadedNode *left, *right;
    int isThreaded; // 1 if right pointer is thread, 0 if it's child
};

struct ThreadedNode* createThreadedNode(int value) {
    struct ThreadedNode* newNode = (struct ThreadedNode*)malloc(sizeof(struct ThreadedNode));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    newNode->isThreaded = 0;
    return newNode;
}

// Function to add nodes can be implemented here

// Example usage
int main() {
    struct ThreadedNode* root = createThreadedNode(10); // Example root node
    // Add additional nodes
    printf("Threaded Binary Tree Created with root node 10.\n");
    return 0;
}
                    </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="3.html">Go to threaded Tree implementation</a>
                </div>
            </div>
        </div>

        <!-- Section 5: YouTube Video -->
        <div class="video-section">
            <h2>Learn More About Trees</h2>
            <iframe width="560" height="315" src="https://www.youtube.com/watch?v=1-l_UOFi1Xw&t=189s" frameborder="0" allowfullscreen></iframe>
            <p>For a deeper understanding, check out this video on trees in data structures.</p>
            <a href="https://www.youtube.com/watch?v=1-l_UOFi1Xw&t=189s" target="_blank">Watch on YouTube</a>
        </div>

        <!-- Section 6: Conclusion -->
        <div class="subsection">
            <h2>Conclusion</h2>
            <p>Trees are an essential data structure in computer science, providing efficient ways to organize and manipulate data. Understanding different types of trees, such as binary trees, binary search trees, and threaded binary trees, is crucial for optimizing algorithms and data processing.</p>
            <a class="btn" href="index.html">Go to Back to home</a>
        </div>

        <!-- Footer Section -->
        <div class="footer">
            <div class="credits">Created by Mohit</div>
        </div>
    </div>

    <script>
        // Function to toggle visibility of sections
        function toggleVisibility(sectionId) {
            const section = document.getElementById(sectionId);
            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        }

        // Initialize all sections to be hidden
        document.addEventListener('DOMContentLoaded', () => {
            const sections = ['terminologies', 'binaryTree', 'bst', 'threadedTree'];
            sections.forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
        });
    </script>
</body>
</html>
