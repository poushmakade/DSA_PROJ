<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trees in DSA: Terminologies, Binary Trees, and Binary Search Trees (BST)</title>
    <link rel="stylesheet" href="sty1.css"> <!-- Linking external CSS -->
    <script src="scr1.js" defer></script> <!-- Linking external JavaScript -->
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 20px;
            transition: background-color 0.5s, color 0.5s;
        }

        h1 {
            text-align: center;
            color: #5aa8f7;
        }

        .content {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #1237ee;
            cursor: pointer;
        }

        p {
            line-height: 1.6;
        }

        .tree-diagram {
            text-align: center;
            margin: 20px 0;
        }

        .footer {
            text-align: right;
            margin-top: 30px;
            color: #888;
            font-size: 12px;
        }

        .subsection {
            margin-top: 40px;
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }

        .video-section {
            background-color: #eafaf1;
            border: 2px solid #1a1c1b;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .video-section a {
            color: #27ae60;
            font-weight: bold;
            text-decoration: underline;
        }

        .credits {
            margin-top: 40px;
            padding: 10px;
            border-top: 1px solid #ccc;
        }

        .code {
            background-color: #f8f8f8;
            border-left: 3px solid #27ae60;
            padding: 10px;
            margin: 20px 0;
            overflow-x: auto;
        }

        pre {
            margin: 0;
            padding: 0;
        }

        /* Button styling */
        .btn {
            display: inline-block;
            margin: 10px 0;
            padding: 10px 20px;
            background-color: #27ae60;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #219150;
        }

        /* Tree diagram styling */
        .tree-representation {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            flex-direction: column;
        }

        .node {
            border: 1px solid #27ae60;
            border-radius: 5px;
            padding: 10px 15px;
            margin: 5px;
            background-color: #eafaf1;
            position: relative;
            text-align: center;
            width: 60px;
        }

        .children {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }

        .horizontal-line {
            position: absolute;
            top: 25px;
            left: 50%;
            width: 50%;
            height: 1px;
            background-color: #27ae60;
            z-index: -1;
        }

        .node.left::after {
            content: '';
            position: absolute;
            width: 50%;
            height: 20px;
            top: 0;
            left: 0;
            border-left: 1px solid #27ae60;
            border-bottom: 1px solid #27ae60;
            border-radius: 0 0 0 5px;
        }

        .node.right::after {
            content: '';
            position: absolute;
            width: 50%;
            height: 20px;
            top: 0;
            right: 0;
            border-right: 1px solid #27ae60;
            border-bottom: 1px solid #27ae60;
            border-radius: 0 0 5px 0;
        }

        .children > .node {
            position: relative;
        }
    </style>
</head>
<body>
    <a class="btn" href="index.html">Home</a>
    <a class="btn" href="contact.html">Contact</a>
    <h1>Trees in DSA: Terminologies, Binary Trees, and Binary Search Trees (BST)</h1>

    <div class="content">
        <!-- Section 1: Basic Tree Terminologies -->
        <h2 onclick="toggleVisibility('terminologies')">Basic Tree Terminologies</h2>
        <div id="terminologies">
            <p>A tree is a hierarchical data structure that consists of nodes connected by edges. It is widely used in various applications such as representing hierarchical relationships, organizing data for quick search and retrieval, and more.</p>
            <ul>
                <li><strong>Node:</strong> A fundamental part of a tree that contains a value or data.</li>
                <li><strong>Root:</strong> The topmost node in a tree. Every tree has a single root node.</li>
                <li><strong>Edge:</strong> A connection between two nodes. It represents the parent-child relationship.</li>
                <li><strong>Parent:</strong> A node that has one or more child nodes.</li>
                <li><strong>Child:</strong> A node that descends from another node (its parent).</li>
                <li><strong>Subtree:</strong> A portion of the tree that consists of a node and all its descendants.</li>
                <li><strong>Height of a Tree:</strong> The longest path from the root to a leaf node.</li>
            </ul>
        </div>

        <!-- Section 2: Binary Tree and Operations -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('binaryTree')">Binary Trees and Operations</h2>
            <div id="binaryTree">
                <p>A binary tree is a type of tree in which each node has at most two children, referred to as the left child and the right child. A binary tree is widely used due to its efficient searching capabilities.</p>

                <h3>Basic Operations of Binary Tree</h3>
                <ul>
                    <li><strong>Inserting a Node:</strong> Inserting data into the binary tree while maintaining its properties.</li>
                    <li><strong>Deleting a Node:</strong> Removing a node while ensuring the tree remains a valid binary tree.</li>
                    <li><strong>Traversal:</strong> Visiting each node in the tree using methods like Pre-order, In-order, and Post-order traversal.</li>
                    <li><strong>Searching:</strong> Finding a node in the binary tree.</li>
                    <li><strong>Height Calculation:</strong> Finding the height of the binary tree, which is the longest path from the root node to a leaf node.</li>
                </ul>

                <h3>Example: Creating and Adding Nodes to a Binary Tree in C</h3>
                <div class="code">
                    <pre>
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int value;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->value) {
        root->left = insert(root->left, value);
    } else if (value > root->value) {
        root->right = insert(root->right, value);
    }
    return root;
}

// Example usage
int main() {
    struct Node* root = NULL;
    root = insert(root, 10);  // Add root node
    insert(root, 5);           // Add left child
    insert(root, 15);          // Add right child
    printf("Binary Tree Created with nodes 10, 5, and 15.\n");
    return 0;
}
                    </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="s.html">Go to Binary Search Tree Implementation</a>
            </div>
        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Binary Search Trees -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('bst')">Binary Search Trees (BST)</h2>
            <div id="bst">
                <p>A Binary Search Tree is a binary tree with the following properties:</p>
                <ul>
                    <li>The left subtree of a node contains only nodes with values less than the node’s value.</li>
                    <li>The right subtree of a node contains only nodes with values greater than the node’s value.</li>
                    <li>Both the left and right subtrees are also binary search trees.</li>
                </ul>

                <h3>Operations on BST</h3>
                <ul>
                    <li><strong>Insertion:</strong> O(log n) in average and O(n) in the worst case.</li>
                    <li><strong>Search:</strong> O(log n) in average and O(n) in the worst case.</li>
                    <li><strong>Delete:</strong> O(log n) in average and O(n) in the worst case (unbalanced tree).</li>
                </ul>

                <h3>C Example: Creating a Binary Search Tree</h3>
                <div class="code">
                    <pre>
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int value;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

struct Node* insertBST(struct Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->value) {
        root->left = insertBST(root->left, value);
    } else {
        root->right = insertBST(root->right, value);
    }
    return root;
}

// Example usage
int main() {
    struct Node* root = NULL;
    root = insertBST(root, 10);  // Add root node
    insertBST(root, 5);           // Add left child
    insertBST(root, 15);          // Add right child
    printf("Binary Search Tree Created with nodes 10, 5, and 15.\n");
    return 0;
}
            </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="2.html">Go to Threaded Binary Tree Implementation</a>
            </div>
        </div>

        <!-- Section 4: Threaded Binary Trees -->
        <div class="subsection">
            <h2 onclick="toggleVisibility('threadedTree')">Threaded Binary Trees</h2>
            <div id="threadedTree">
                <p>A threaded binary tree is a type of binary tree where the null pointers of the nodes are made to point to the in-order predecessor and successor. This allows for efficient in-order traversal without using a stack or recursion.</p>

                <h3>Advantages of Threaded Binary Trees</h3>
                <ul>
                    <li>Improved traversal efficiency.</li>
                    <li>Reduces the overhead of using a stack for traversal.</li>
                    <li>Memory-efficient as it utilizes the null pointers.</li>
                </ul>

                <h3>C Example: Creating a Threaded Binary Tree</h3>
                <div class="code">
                    <pre>
struct ThreadedNode {
    int value;
    struct ThreadedNode *left, *right;
    int isThreaded; // 1 if right pointer is thread, 0 if it's child
};

struct ThreadedNode* createThreadedNode(int value) {
    struct ThreadedNode* newNode = (struct ThreadedNode*)malloc(sizeof(struct ThreadedNode));
    newNode->value = value;
    newNode->left = newNode->right = NULL;
    newNode->isThreaded = 0;
    return newNode;
}

// Function to add nodes can be implemented here

// Example usage
int main() {
    struct ThreadedNode* root = createThreadedNode(10); // Example root node
    // Add additional nodes
    printf("Threaded Binary Tree Created with root node 10.\n");
    return 0;
}
                    </pre>
                </div>

                <h3>Actions</h3>
                <a class="btn" href="3.html">Go to threaded Tree implementation</a>
                </div>
            </div>
        </div>

        <!-- Section 5: YouTube Video -->
        <div class="video-section">
            <h2>Learn More About Trees</h2>
            <iframe width="560" height="315" src="https://www.youtube.com/watch?v=1-l_UOFi1Xw&t=189s" frameborder="0" allowfullscreen></iframe>
            <p>For a deeper understanding, check out this video on trees in data structures.</p>
            <a href="https://www.youtube.com/watch?v=1-l_UOFi1Xw&t=189s" target="_blank">Watch on YouTube</a>
        </div>

        <!-- Section 6: Conclusion -->
        <div class="subsection">
            <h2>Conclusion</h2>
            <p>Trees are an essential data structure in computer science, providing efficient ways to organize and manipulate data. Understanding different types of trees, such as binary trees, binary search trees, and threaded binary trees, is crucial for optimizing algorithms and data processing.</p>
            <a class="btn" href="index.html">Go to Back to home</a>
        </div>

        <!-- Footer Section -->
        <div class="footer">
            <div class="credits">Created by Mohit</div>
        </div>
    </div>

    <script>
        // Function to toggle visibility of sections
        function toggleVisibility(sectionId) {
            const section = document.getElementById(sectionId);
            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        }

        // Initialize all sections to be hidden
        document.addEventListener('DOMContentLoaded', () => {
            const sections = ['terminologies', 'binaryTree', 'bst', 'threadedTree'];
            sections.forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
        });
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Implementation in DSA</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            background-color: #121212; /* Dark background */
            color: #ffffff; /* White text */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #1f1f1f;
            padding: 20px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            animation: fadeInUp 1s ease-in-out;
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        nav a {
            color: #ffffff;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease, transform 0.3s ease;
        }

        nav a:hover {
            color: #ff9800;
            transform: scale(1.1);
        }

        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #1f1f1f;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            animation: fadeIn 1.5s ease-in-out;
        }

        h1, h2, h3 {
            color: #ff9800; /* Orange for headings */
            font-family: 'Georgia', serif;
        }

        p, li {
            color: #e0e0e0; /* Light grey text */
        }

        code {
            display: block;
            background-color: #2a2a2a; /* Slightly lighter than background */
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-size: 16px;
            color: #ff9800; /* Orange for code */
            overflow-x: auto;
        }

        a {
            color: #ff9900; /* Bright orange for links */
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .footer {
            margin-top: 30px;
            font-size: 14px;
            color: #888;
            text-align: center;
        }

        /* Tree Visualization Styles */
        .tree-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        svg {
            width: 100%;
            height: auto;
            max-width: 800px;
        }

        circle {
            fill: #ff9800; /* Orange nodes */
        }

        text {
            fill: #ffffff;
            font-weight: bold;
            font-size: 12px;
        }

        .btn-container {
            text-align: center;
            margin-top: 20px;
        }

        .btn {
            background-color: #ff9800;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .btn:hover {
            background-color: #e68a00;
        }

        .created-by {
            position: fixed;
            right: 20px;
            bottom: 20px;
            color: #888;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="index.html">Home</a>
            <a href="algorithms.html">Algorithms</a>
            <a href="credits.html">Credits</a>
            <a href="contact.html">Contact</a>
        </nav>
    </header>
    <div class="container">
        <h1>Tree Implementation in Data Structures and Algorithms</h1>

        <p>A tree is a hierarchical data structure that consists of nodes connected by edges. It is used to represent hierarchical relationships and is a fundamental concept in computer science.</p>

        <h2>Types of Trees</h2>
        <ul>
            <li><strong>Binary Tree:</strong> Each node has at most two children.</li>
            <li><strong>Binary Search Tree (BST):</strong> A binary tree where the left subtree of a node contains only nodes with values less than the node's key, and the right subtree contains nodes with values greater than the node's key.</li>
            <li><strong>AVL Tree:</strong> A self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one.</li>
            <li><strong>Red-Black Tree:</strong> A self-balancing binary search tree with additional properties to ensure the tree remains balanced.</li>
            <li><strong>N-ary Tree:</strong> A tree data structure where a node can have at most N children.</li>
        </ul>

        <h2>Tree Visualization Example</h2>
        <p>Below are graphical representations of Binary Search Tree and AVL Tree.</p>

        <!-- Binary Search Tree Visualization SVG -->
        <div class="tree-container">
            <svg viewBox="0 0 500 500" id="bst-visual">
                <line x1="250" y1="100" x2="150" y2="200" stroke="white" stroke-width="2"/>
                <line x1="250" y1="100" x2="350" y2="200" stroke="white" stroke-width="2"/>
                <circle cx="250" cy="100" r="20"></circle>
                <text x="245" y="105">50</text>

                <line x1="150" y1="200" x2="100" y2="300" stroke="white" stroke-width="2"/>
                <line x1="150" y1="200" x2="200" y2="300" stroke="white" stroke-width="2"/>
                <circle cx="150" cy="200" r="20"></circle>
                <text x="145" y="205">30</text>

                <line x1="350" y1="200" x2="300" y2="300" stroke="white" stroke-width="2"/>
                <line x1="350" y1="200" x2="400" y2="300" stroke="white" stroke-width="2"/>
                <circle cx="350" cy="200" r="20"></circle>
                <text x="345" y="205">70</text>
            </svg>
        </div>

        <h3>Binary Search Tree (BST) Example in C</h3>
        <code>
            <span style="color: #ff9800;">#include &lt;stdio.h&gt;</span><br>
            <span style="color: #ff9800;">#include &lt;stdlib.h&gt;</span><br><br>
            <span style="color: #ff9800;">// Node structure</span><br>
            <span style="color: #00ffff;">struct Node {</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ff00;">int data;</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node* left;</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node* right;</span><br>
            <span style="color: #00ffff;">};</span><br><br>

            <span style="color: #00ffff;">// Create a new node</span><br>
            <span style="color: #00ffff;">struct Node*</span> newNode(<span style="color: #00ff00;">int</span> data) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> node = (<span style="color: #00ffff;">struct Node*</span>)malloc(sizeof(struct Node));<br>
            &nbsp;&nbsp;&nbsp;&nbsp;node-&gt;data = data;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;node-&gt;left = NULL;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;node-&gt;right = NULL;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return node;<br>
            }<br><br>

            <span style="color: #00ffff;">// Insert a new node</span><br>
            <span style="color: #00ffff;">struct Node*</span> insert(<span style="color: #00ffff;">struct Node*</span> node, <span style="color: #00ff00;">int</span> data) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (node == NULL) return newNode(data);<br>
            <span style="color: #00ff00;">if</span> (data &lt; node-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;left = insert(node-&gt;left, data);<br>
            <span style="color: #00ff00;">else if</span> (data &gt; node-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;right = insert(node-&gt;right, data);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return node;<br>
            }<br><br>

            <span style="color: #00ffff;">// Inorder traversal</span><br>
            <span style="color: #00ffff;">void</span> inorder(<span style="color: #00ffff;">struct Node*</span> root) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (root != NULL) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inorder(root-&gt;left);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d &quot;, root-&gt;data);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inorder(root-&gt;right);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            }<br><br>

            <span style="color: #00ffff;">int</span> main() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> root = NULL;<br>
            root = insert(root, 50);<br>
            insert(root, 30);<br>
            insert(root, 20);<br>
            insert(root, 40);<br>
            insert(root, 70);<br>
            insert(root, 60);<br>
            insert(root, 80);<br><br>

            printf(&quot;Inorder traversal of the binary search tree:\n&quot;);<br>
            inorder(root);<br>
            printf(&quot;\n&quot;);<br><br>

            <span style="color: #00ffff;">return</span> 0;<br>
            }
        </code>

        <h2>AVL Tree Visualization Example</h2>
        <div class="tree-container">
            <svg viewBox="0 0 500 500" id="avl-visual">
                <line x1="250" y1="100" x2="150" y2="200" stroke="white" stroke-width="2"/>
                <line x1="250" y1="100" x2="350" y2="200" stroke="white" stroke-width="2"/>
                <circle cx="250" cy="100" r="20"></circle>
                <text x="245" y="105">30</text>

                <line x1="150" y1="200" x2="100" y2="300" stroke="white" stroke-width="2"/>
                <line x1="150" y1="200" x2="200" y2="300" stroke="white" stroke-width="2"/>
                <circle cx="150" cy="200" r="20"></circle>
                <text x="145" y="205">20</text>

                <line x1="150" y1="200" x2="180" y2="300" stroke="white" stroke-width="2"/>
                <line x1="350" y1="200" x2="300" y2="300" stroke="white" stroke-width="2"/>
                <circle cx="350" cy="200" r="20"></circle>
                <text x="345" y="205">40</text>
                <circle cx="350" cy="100" r="20"></circle>
                <text x="345" y="105">60</text>
            </svg>
        </div>

        <h3>AVL Tree Example in C</h3>
        <code>
            <span style="color: #ff9800;">#include &lt;stdio.h&gt;</span><br>
            <span style="color: #ff9800;">#include &lt;stdlib.h&gt;</span><br>
            <span style="color: #ff9800;">#include &lt;math.h&gt;</span><br><br>
            <span style="color: #00ffff;">struct Node {</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ff00;">int data;</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node* left;</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node* right;</span><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">int height;</span><br>
            <span style="color: #00ffff;">};</span><br><br>

            <span style="color: #00ffff;">int</span> height(<span style="color: #00ffff;">struct Node*</span> node) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">return</span> (node == NULL) ? 0 : node-&gt;height;<br>
            }<br><br>

            <span style="color: #00ffff;">int</span> balanceFactor(<span style="color: #00ffff;">struct Node*</span> node) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">return</span> (node == NULL) ? 0 : height(node-&gt;left) - height(node-&gt;right);<br>
            }<br><br>

            <span style="color: #00ffff;">struct Node*</span> rightRotate(<span style="color: #00ffff;">struct Node*</span> y) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> x = y-&gt;left;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> T2 = x-&gt;right;<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;x-&gt;right = y;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;y-&gt;left = T2;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;y-&gt;height = fmax(height(y-&gt;left), height(y-&gt;right)) + 1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;x-&gt;height = fmax(height(x-&gt;left), height(x-&gt;right)) + 1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return x;<br>
            }<br><br>

            <span style="color: #00ffff;">struct Node*</span> leftRotate(<span style="color: #00ffff;">struct Node*</span> x) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> y = x-&gt;right;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> T2 = y-&gt;left;<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;y-&gt;left = x;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;x-&gt;right = T2;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;x-&gt;height = fmax(height(x-&gt;left), height(x-&gt;right)) + 1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;y-&gt;height = fmax(height(y-&gt;left), height(y-&gt;right)) + 1;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return y;<br>
            }<br><br>

            <span style="color: #00ffff;">struct Node*</span> insert(<span style="color: #00ffff;">struct Node*</span> node, <span style="color: #00ff00;">int</span> data) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (node == NULL) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newNode(data);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (data &lt; node-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;left = insert(node-&gt;left, data);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;else if (data &gt; node-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;right = insert(node-&gt;right, data);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;node-&gt;height = 1 + fmax(height(node-&gt;left), height(node-&gt;right));<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;int balance = balanceFactor(node);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (balance &gt; 1 &amp;&amp; data &lt; node-&gt;left-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return rightRotate(node);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (balance &lt; -1 &amp;&amp; data &gt; node-&gt;right-&gt;data)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return leftRotate(node);<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (balance &gt; 1 &amp;&amp; data &gt; node-&gt;left-&gt;data) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;left = leftRotate(node-&gt;left);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return rightRotate(node);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (balance &lt; -1 &amp;&amp; data &lt; node-&gt;right-&gt;data) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node-&gt;right = rightRotate(node-&gt;right);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return leftRotate(node);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;return node;<br>
            }<br><br>

            <span style="color: #00ffff;">int</span> main() {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #00ffff;">struct Node*</span> root = NULL;<br>
            root = insert(root, 10);<br>
            root = insert(root, 20);<br>
            root = insert(root, 30);<br>
            root = insert(root, 40);<br>
            root = insert(root, 50);<br>
            root = insert(root, 25);<br><br>

            printf(&quot;Inorder traversal of the AVL tree:\n&quot;);<br>
            inorder(root);<br>
            printf(&quot;\n&quot;);<br><br>

            <span style="color: #00ffff;">return</span> 0;<br>
            }
        </code>
    </div>

    <div class="footer">Created by Mohit</div>
</body>
</html>
